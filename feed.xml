<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://maciejmalecki.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://maciejmalecki.github.io/blog/" rel="alternate" type="text/html" /><updated>2019-11-12T20:40:57+00:00</updated><id>https://maciejmalecki.github.io/blog/</id><title type="html">()=&amp;gt;{} | Void’s blog</title><subtitle>t.b.d.</subtitle><author><name>Maciej Małecki</name></author><entry><title type="html">Put subroutine into the library</title><link href="https://maciejmalecki.github.io/blog/macro-hosted-subroutines" rel="alternate" type="text/html" title="Put subroutine into the library" /><published>2018-08-02T00:00:00+00:00</published><updated>2018-08-02T00:00:00+00:00</updated><id>https://maciejmalecki.github.io/blog/macro-hosted-subroutines</id><content type="html" xml:base="https://maciejmalecki.github.io/blog/macro-hosted-subroutines">&lt;p&gt;Subroutine is an essential concept in programming. Advantages of using subroutines are quite clear - instead of doing a repetitive work, we define chunk of code once and “jump” to it any time we need it. It is a part of DRY principle (do not repeat yourself), which allows to keep our code compact and maintainable. It allows us to keep memory footprint of our code at reasonable level. With possibility of passing execution arguments as well as result, subroutines become fully blown procedures and functions as known from high level languages.&lt;/p&gt;

&lt;p&gt;How does MOS 6502 support subroutines? We essentially need two instructions: “&lt;strong&gt;J&lt;/strong&gt;ump to &lt;strong&gt;S&lt;/strong&gt;ub&lt;strong&gt;R&lt;/strong&gt;outine” that does typical long jump to given memory address and “&lt;strong&gt;R&lt;/strong&gt;e&lt;strong&gt;T&lt;/strong&gt;urn from &lt;strong&gt;S&lt;/strong&gt;ubroutine” that returns to the address pointing to the next instruction after “jump”. These instructions are named &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;RTS&lt;/code&gt;, respectively. &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR&lt;/code&gt; does actually more than simple &lt;code class=&quot;highlighter-rouge&quot;&gt;JMP&lt;/code&gt; - it pushes return address to the stack (MOS 6502 uses memory page 1 for stack: addresses from &lt;code class=&quot;highlighter-rouge&quot;&gt;$100&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;$1FF&lt;/code&gt;). &lt;code class=&quot;highlighter-rouge&quot;&gt;RTS&lt;/code&gt; pulls return address from stack and stores it as program counter (PC).&lt;/p&gt;

&lt;p&gt;For all of you my readers who like to be very accurate, the address stored by &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR&lt;/code&gt; is decremented by 1, &lt;code class=&quot;highlighter-rouge&quot;&gt;RTS&lt;/code&gt; does increment it back by 1. I don’t even want to know why, I bet somebody wanted to make some savings on transistor count, it’s just my quess…&lt;/p&gt;

&lt;h2 id=&quot;communicating-with-subroutines---parameters&quot;&gt;Communicating with subroutines - parameters&lt;/h2&gt;
&lt;p&gt;In 6502 machine code there are at least three commonly used methods for passing parameters to the subroutine:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Using processor registers.&lt;/li&gt;
  &lt;li&gt;Using fixed memory locations (via global variables).&lt;/li&gt;
  &lt;li&gt;Using stack.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using CPU registers is the simplest possible way of communication. Assuming that registers are used wisely, we may get CPU registers already properly loaded with values which speeds up execution and can be essential in some time critical cases. There is however one downside of this method directly connected with very simplistic design of 6502: there are only 3 registers that can be easily used (&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;) each only 1 byte in size - not much indeed.&lt;/p&gt;

&lt;p&gt;Fixed memory location for exchanging parameters is fine unless you write libraries of code. With library code we cannot assume that certain memory locations can be used by our subroutines, because there is no way to predict what would be memory layout of the client program.&lt;/p&gt;

&lt;p&gt;Finally there is a stack, that is 256 bytes of memory located in already mentioned page 1. Stack is a data structure with very limited API, that is we can push value there or pull value from there, there is a stack pointer that indicates where new value will be pushed or pulled that is incremented or decremented automatically with &lt;code class=&quot;highlighter-rouge&quot;&gt;PLA&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;PHA&lt;/code&gt; instruction executions. We can put our parameters on the stack right before &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR&lt;/code&gt; is executed and then use it inside of our subroutine.&lt;/p&gt;

&lt;p&gt;In next chapters I will describe latter two methods as the most promising for our purposes. Communication with CPU registers as the most straightforward method can also be used, if only amount of data needed in communication is limited.&lt;/p&gt;

&lt;h2 id=&quot;hosted-subroutines&quot;&gt;Hosted subroutines&lt;/h2&gt;
&lt;p&gt;As it has been already mentioned in my &lt;a href=&quot;assembler-libraries&quot;&gt;library post&lt;/a&gt;, libraries in KickAssembler can be realized with &lt;code class=&quot;highlighter-rouge&quot;&gt;#import&lt;/code&gt; macro by importing source file of library into client code. Anything that is not a macro, label or function, which means any ‘free floating’ pieces of code or data prepended with memory directives will get its own memory segment and will be assembled together with client code. There is no special control over this process, at least I don’t know about any. That is a problem because any piece of code will immediately steal some memory during assembling no matter you’re going to use it or not. This will lead us to the design, where each subroutine has its own source file which does not seem to be reasonable nor convenient.&lt;/p&gt;

&lt;p&gt;But wait, macros are KickAssembler entities that are not automatically resolved into a code! They must be called first. They can be called many times and this is something, we frequently do with short macros. With long macros (and subroutine macros can be potentially very lenghty) it might be no so good idea because we will waste so much memory.&lt;/p&gt;

&lt;p&gt;I have very quickly concluded, that we should use only macros in KickAssembler library code and not free floating code at all. There is only one inconvenience, that we have to call such a macro at least one in library client code to “install” our subroutine.&lt;/p&gt;

&lt;p&gt;KickAssembler macros can have parameters. One may think this is a perfect way to communicate with our subroutines. But this is false thinking - macro parameters can be used to communicate with macro, not with hosted subroutine.&lt;/p&gt;

&lt;p&gt;Let’s consider following example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.macro add8(left, right) {
    lda #left
    adc #right
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This macro, when used loads accumulator with value &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;, adds value &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt; to it and leaves result in accumulator. One may think “cool, that’s useful”. But in reality it is not. We get “subroutine” that takes two parameters, but values of these parameters must be calculated during assembling process. No way to pass accumulator values, or memory values or anything calculated. All we can do is to:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add8(2, 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and get &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt; in accumulator.&lt;/p&gt;

&lt;h2 id=&quot;make-global-variable-communication-useful&quot;&gt;Make global variable communication useful&lt;/h2&gt;
&lt;p&gt;As it was already mentioned, biggest challenge with communicating using memory location is that this location must be somehow fixed. This theoretically disqualifies such method for librarian subroutines. But what if such memory location is made configurable?&lt;/p&gt;

&lt;p&gt;Let’s consider our trivial example once more, this time we will write macro based subroutine that takes values from two memory locations, adds them together and leaves result in accumulator:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.macro add8Mem(leftPtr, rightPtr) {
    lda leftPtr
    adc rightPtr
    rts
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assuming that we have encapsulated this macro in library, namely &lt;code class=&quot;highlighter-rouge&quot;&gt;math.asm&lt;/code&gt;, we can now write following “client” program:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;math.asm&quot;

*=$0801 &quot;Basic upstart&quot;
BasicUpstart(start)

*=$3000 &quot;Program&quot;
start:
    lda #2      // take 2...
    sta $02     // and store it as first argument
    lda #4      // take 4...
    sta $03     // and store it as second argument
    jsr add8Mem // call subroutine that will adds values from $02 and $03
    sta $04     // result from A can be then stored anywhere, i.e.: under $04

    ...         // and the program continues...

add8Mem:        // under this address we install our subroutine
    add8Mem($02, $03) // subroutine is configured to use $02 and $03 as
                      // parameter placeholders
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here we did several things:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We have installed our subroutine using library macro under address of choice (here indicated by &lt;code class=&quot;highlighter-rouge&quot;&gt;add8Mem&lt;/code&gt; address (I’m going to use label name that follows macro name, but it does not need to go like this).&lt;/li&gt;
  &lt;li&gt;We have configured this subroutine to use addresses of choice for parameter placeholders (we did it using macro parameters).&lt;/li&gt;
  &lt;li&gt;We can use subroutine with simple &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR&lt;/code&gt;, all we need to do is to load placeholders with data first.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Subroutine, once installed, can be called many times, from different places of code - it will work just fine.&lt;/p&gt;

&lt;p&gt;As you can see, with this approach we can use macros as hosts for our subroutines and additionally we have ability to freely configure placeholders.&lt;/p&gt;

&lt;h2 id=&quot;using-stack&quot;&gt;Using stack&lt;/h2&gt;
&lt;p&gt;Stack in MOS 6502 is just a regular place in memory. CPU has three additional components that handles stack in convenient and fast way: it is stack pointer register (SP) and families of push and pull instructions that can transfer data from and to CPU registers. When we use stack for subroutine parameters, it is particularily convenient, because we don’t need to care which exact memory cells should we use for this purpose. Just free place on stack will be used. Moreover, this method of communication supports nesting of subroutine calls, and with particularily clever design it may even handle recursive calls.&lt;/p&gt;

&lt;p&gt;Lets consider &lt;code class=&quot;highlighter-rouge&quot;&gt;add8&lt;/code&gt; subroutine hosted by a macro (similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;add8Mem&lt;/code&gt; from above) but using stack as communication method. First we have to deal with return address. It is very important to preserve it, because without correctly defined return address our CPU will get jammed as soon as &lt;code class=&quot;highlighter-rouge&quot;&gt;RTS&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;Return address is pushed to the stack once &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR&lt;/code&gt; is called and taken back when &lt;code class=&quot;highlighter-rouge&quot;&gt;RTS&lt;/code&gt; is called. We are going to push our parameters to the stack just before &lt;code class=&quot;highlighter-rouge&quot;&gt;JSR&lt;/code&gt;, so at the beginning of our subroutine we must pull this address and store somewhere else before accessing our parameters.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.macro add8() {
    // pull return address and store in placeholder
    pla; sta returnPtr
    pla; sta returnPtr + 1

    // pull second argument
    pla; sta rightPtr + 1
    // pull first argument
    pla; sta leftPtr + 1

  leftPtr:
    lda #$00
  rightPtr:
    adc #$00
    sta resultPtr

    // restore return address
    lda returnPtr + 1; pha
    lda returnPtr; pha
    // move result to A
    lda resultPtr
    rts
  returnPtr: .word 0
  resultPtr: .byte 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our program that utilizes following hosted subroutine can look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;math.asm&quot;

*=$0801 &quot;Basic upstart&quot;
BasicUpstart(start)

*=$3000 &quot;Program&quot;
start:
    lda #2      // take 2...
    pha         // and store it as first argument
    lda #4      // take 4...
    pha         // and store it as second argument
    jsr add8    // call subroutine that will adds values that are stored on the stack
    sta $04

    ...         // and the program continues...

add8:           // under this address we install our subroutine
    add8()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is actually plenty of coding. We can simplify this with bunch of KickAssembler macros. This time we will utilize macros as they should be utilized - to replace short, repetitive pieces of code.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.macro @invokeStackBegin(placeholderPtr) {
    pla
    sta placeholderPtr
    pla
    sta placeholderPtr + 1
}

.macro @invokeStackEnd(placeholderPtr) {
    lda placeholderPtr + 1
    pha
    lda placeholderPtr
    pha
}

.macro @pushParamB(value) {
    lda #value
    pha
}

.macro @pullParamB(placeholderPtr) {
    pla
    sta placeholderPtr
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With these macros we can code our macro hosted subroutine in simpler manner (please appreciate the beauty of this self modifying code):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.macro add8() {
    invokeStackBegin(returnPtr)
    pullParamB(rightPtr + 1)
    pullParamB(leftPtr + 1)

  leftPtr:
    lda #$00
  rightPtr:
    adc #$00
    sta resultPtr

    invokeStackEnd(returnPtr)
    lda resultPtr
    rts
  returnPtr: .word 0
  resultPtr: .byte 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and calling code can look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;start:
    pushParamB(2)
    pushParamB(4)
    jsr add8    // call subroutine that will adds values that are stored on the stack
    sta $04

    ...         // and the program continues...

add8:           // under this address we install our subroutine
    add8()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Helper macros for implementing stack based subroutines are available as KickAssembler library as a part of c64lib. You must include &lt;code class=&quot;highlighter-rouge&quot;&gt;invoke.asm&lt;/code&gt; from common repository (https://github.com/c64lib/common).&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;We just saw how subroutines can be effectively implemented as part of libraries. With this approach they can be easily installed into target code and reused by many programs. We’ve learnt also how can we pass parameters to the subroutines. With a little help from self modifying code and some macros from c64lib common library we can write compact code that communicates via stack. I will post some more complex examples in subsequent posts, including indirect subroutine parameters.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;[1] &lt;a href=&quot;assembler-libraries&quot;&gt;assembler-libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Maciej Małecki</name></author><summary type="html">Subroutine is an essential concept in programming. Advantages of using subroutines are quite clear - instead of doing a repetitive work, we define chunk of code once and “jump” to it any time we need it. It is a part of DRY principle (do not repeat yourself), which allows to keep our code compact and maintainable. It allows us to keep memory footprint of our code at reasonable level. With possibility of passing execution arguments as well as result, subroutines become fully blown procedures and functions as known from high level languages.</summary></entry><entry><title type="html">Writing and using libraries in KickAssembler</title><link href="https://maciejmalecki.github.io/blog/assembler-libraries" rel="alternate" type="text/html" title="Writing and using libraries in KickAssembler" /><published>2018-04-26T00:00:00+00:00</published><updated>2018-04-26T00:00:00+00:00</updated><id>https://maciejmalecki.github.io/blog/assembler-libraries</id><content type="html" xml:base="https://maciejmalecki.github.io/blog/assembler-libraries">&lt;p&gt;It’s a long way I took from early times when I coded something for MOS 65XX family to now, when I actually code for money. What was really a joy or hobby, now becomes a rather routine work guided by corporate processes, software frameworks and project management methodologies. I do not want to complain, I fully understand that productivity is a key and live is hard.&lt;/p&gt;

&lt;p&gt;When I came back to C64 programming, and that was roughly two years ago (2016) I was just a little bit bored being sick listed because of backbone problems (something very common for programmers of my age). I jumped into very fast, watched bit of excellent &lt;a href=&quot;https://64bites.com/&quot;&gt;64bites&lt;/a&gt;, discovered a wonderful pair of &lt;a href=&quot;http://www.theweb.dk/KickAssembler/Main.html&quot;&gt;KickAssembler&lt;/a&gt; and &lt;a href=&quot;http://www.popelganda.de/relaunch64.html&quot;&gt;Relaunch64&lt;/a&gt; and then endless source of information, such as &lt;a href=&quot;http://codebase64.org&quot;&gt;Codebase64&lt;/a&gt; and &lt;a href=&quot;https://cadaver.github.io/&quot; title=&quot;Covert Bitops&quot;&gt;CovertBitops&lt;/a&gt;, to mention just a few.&lt;/p&gt;

&lt;p&gt;To my great surprise I soon discovered, that something is missing: definitive some processes such as automated builds or CI (continous integration). I’m looking for ready to use, well tested libraries and dependency management system and couldn’t find any.&lt;/p&gt;

&lt;p&gt;(However, I do not miss any management methodologies…)&lt;/p&gt;

&lt;p&gt;Just to unlock my brain at this moment, I decided that:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I will use &lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt; to store and version my code&lt;/li&gt;
  &lt;li&gt;I will use &lt;a href=&quot;https://travis-ci.org&quot;&gt;TravisCI&lt;/a&gt; to run continous integration of my code&lt;/li&gt;
  &lt;li&gt;I will use excellent features of &lt;a href=&quot;http://www.theweb.dk/KickAssembler/Main.html&quot;&gt;KickAssembler&lt;/a&gt; such as macros, functions and directives and try to write generic, reusable assembly code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Challenge accepted.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-library&quot;&gt;What is a library?&lt;/h2&gt;
&lt;p&gt;Library is just a piece of code that anybody can reuse in other projects just to boost productivity. There are few assumptions that everybody should consider: such code must offer stable API, must be properly versioned (such as I need to use exact version 1.4.0, nothing older but also nothing newer).&lt;/p&gt;

&lt;p&gt;What does it mean in practice?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We need to use any form of source control (GIT and &lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt; with its “Releases” feature fits here perfectly).&lt;/li&gt;
  &lt;li&gt;It would be great to have central repository of libraries and dependency management tool just to be able to install or upgrade a library with single CLI command (there are a lot of solutions for other languages such as NPM for JavaScript, PIP for Python, Gems for Ruby, Maven Nexus for Java but sadly nothing for C64 assembly).&lt;/li&gt;
  &lt;li&gt;It would be great that we can integrate assembling and dependency management process into one tool so that we can write “builds” (like with maven, gulp, angular cli, rake).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Later I will show, how can we at least partially address these issues for KickAssembler-written libs.&lt;/p&gt;

&lt;h2 id=&quot;what-should-we-put-into-library&quot;&gt;What should we put into library?&lt;/h2&gt;
&lt;p&gt;In order to create flexible solution I decided that I will always wrap assembly code in macro while in library. This has two major advantages:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Macros can be parametrized, which gives us additional flexibility.&lt;/li&gt;
  &lt;li&gt;We have full freedom where to use macro and thus where in memory will resulting code be located.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s assume we have following code in our library:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.macro inc16(destination) {
  inc destination
  bne !+
  inc destination + 1
!:
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It increments 16 bit number placed in memory in two memory cells: &lt;code class=&quot;highlighter-rouge&quot;&gt;destination&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;destination+1&lt;/code&gt; (little endian). Every time it is used it will be exchanged with 3 instructions weighting 8 bytes in total. Of course we can use such “library call” many times, each time we’re adding 8 bytes to total length of our code.&lt;/p&gt;

&lt;p&gt;There are two more useful types of items we can declare in our library.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.theweb.dk/KickAssembler/Main.html&quot;&gt;KickAssembler&lt;/a&gt; offers functions, that itself does not evaluate into assembly code but can calculate values that can be later used as immediate value in assembly or in macros.&lt;/p&gt;

&lt;p&gt;Lets’s consider following function:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.function getTextMemory(screenMem, charSet) {
  .return charSet&amp;lt;&amp;lt;1 | screenMem&amp;lt;&amp;lt;4
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What it does it takes screenMemory slot and charsetSlot and combines it together to get value that can be then stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;$D018&lt;/code&gt; register of VIC-II. This can be used for every 3 text modes of C64. This is how we can use it in code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lda #getTextMemory(1, 4)
sta MEMORY_CONTROL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Or we can even wrap it into library macro:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.macro configureTextMemory(screenMem, charSet) {
  lda #getTextMemory(screenMem, charSet)
  sta MEMORY_CONTROL
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and then use in code like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;configureTextMemory(1, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Last useful item is label. Labels can be used to define constants that can be then reused in different part of library, other libraries or programs. It is definitely easier to read &lt;code class=&quot;highlighter-rouge&quot;&gt;sta MEMORY_CONTROL&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;sta $D017&lt;/code&gt;, isn’t it?&lt;/p&gt;

&lt;p&gt;Here’s example: a beginning of declaration for all VIC-II registers:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* ------------------------------------
 * VIC-II registers.
 * ------------------------------------ */
.label VIC2                 = $D000 
.label SPRITE_0_X           = VIC2 + $00 
.label SPRITE_0_Y           = VIC2 + $01 
.label SPRITE_1_X           = VIC2 + $02 
.label SPRITE_1_Y           = VIC2 + $03 
.label SPRITE_2_X           = VIC2 + $04 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;how-can-we-write-libraries-in-assembly&quot;&gt;How can we write libraries in assembly?&lt;/h2&gt;
&lt;p&gt;There are three features of &lt;a href=&quot;http://www.theweb.dk/KickAssembler/Main.html&quot;&gt;KickAssembler&lt;/a&gt; that are handy here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;#import&lt;/code&gt; directive that includes specified &lt;code class=&quot;highlighter-rouge&quot;&gt;asm&lt;/code&gt; file into source code.&lt;/li&gt;
  &lt;li&gt;The namespace feature that allows to isolate objects of library so that they don’t clash with identically named objects of another library.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;-libdir&lt;/code&gt; parameter that allows to specify additional directory where &lt;a href=&quot;http://www.theweb.dk/KickAssembler/Main.html&quot;&gt;KickAssembler&lt;/a&gt; will look for files to import, so we can keep our libraries checked out in separate folder.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets look at trivial example: a common library without any additional dependencies: &lt;a href=&quot;https://github.com/c64lib/common&quot;&gt;https://github.com/c64lib/common&lt;/a&gt;. It consists of several files:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; - these are several build artifacts of KickAssembler that should never be stored in GIT such as &lt;code class=&quot;highlighter-rouge&quot;&gt;*.prg&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*.sym&lt;/code&gt; files but also a &lt;code class=&quot;highlighter-rouge&quot;&gt;.cbm&lt;/code&gt; directory (I will explain that later).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.travis.yml&lt;/code&gt; - config file for &lt;a href=&quot;https://travis-ci.org&quot;&gt;TravisCI&lt;/a&gt; - also to be described later.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LICENSE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt; - speak for themselves.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;common.asm&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mem.asm&lt;/code&gt; - library files&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First thing that we see is that it is actually possible to keep several library (asm) files in single ‘library’ module. Splitting code into few smaller files is always good as long as separation is semantically consistent and reasonable.&lt;/p&gt;

&lt;p&gt;Take a look into &lt;code class=&quot;highlighter-rouge&quot;&gt;common.asm&lt;/code&gt; - it is really trivial and short:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#importonce
.filenamespace c64lib

/*
 * Why Kickassembler does not support bitwise negation on numerical values?
 * 
 * Params:
 * value: byte to be negated
 */
.function neg(value) {
	.return value ^ $FF
}
.assert &quot;neg($00) gives $FF&quot;, neg($00), $FF
.assert &quot;neg($FF) gives $00&quot;, neg($FF), $00
.assert &quot;neg(%10101010) gives %01010101&quot;, neg(%10101010), %01010101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What is important is header: &lt;code class=&quot;highlighter-rouge&quot;&gt;#importonce&lt;/code&gt; says that such file should be imported only once no matter how many times this particular library file is used by all other libraries and files used to assembly our project.&lt;/p&gt;

&lt;p&gt;Then I declare a namespace: &lt;code class=&quot;highlighter-rouge&quot;&gt;c64lib&lt;/code&gt;. I decided to use single namespace for all my libraries because of the namespace problem I have discovered (described in details later). Having separate namespace per library will force me to declare all items ‘public’ which I wanted to avoid.&lt;/p&gt;

&lt;p&gt;Then we have function documentation (quite important for libraries) - this is logical negation function, by some reason such function is not available in &lt;a href=&quot;http://www.theweb.dk/KickAssembler/Main.html&quot;&gt;KickAssembler&lt;/a&gt; out of the box.&lt;/p&gt;

&lt;p&gt;Then I wrote several tests in form of KickAssembler asserts: why not to write some unit tests if there is such possibility given by assembler?&lt;/p&gt;

&lt;h2 id=&quot;small-problems&quot;&gt;Small problems&lt;/h2&gt;
&lt;p&gt;Sadly there are few shortcommings of &lt;a href=&quot;http://www.theweb.dk/KickAssembler/Main.html&quot;&gt;KickAssembler&lt;/a&gt; as for now (version 4.x), which make things a little bit more complicated.&lt;/p&gt;

&lt;p&gt;Firstly, it is not possible to specify more than one diectory with &lt;code class=&quot;highlighter-rouge&quot;&gt;-libdir&lt;/code&gt; switch. This is quite easy to workaround - either we need to checkout all libraries into single, common directory, or we can keep it separated and than assemble it into ‘virtual folder’ using symbolic links.&lt;/p&gt;

&lt;p&gt;Second problem is unfortunately more problematic. The namespace feature is great, as it allows to group labels, macros and functions. But macros and functions are not visible from outside of that particular namespace. So, when you write following code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.namespace c64lib {
  .label VIC2 = $D000 
  .label MEMORY_CONTROL = VIC2 + $18
  .label TEXT_SCREEN_WIDTH = 40
  
  .function getTextOffset(xPos, yPos) {
    .return xPos + TEXT_SCREEN_WIDTH * yPos
  }

  .macro configureTextMemory(video, charSet) {
    lda #getTextMemory(video, charSet)
    sta MEMORY_CONTROL
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;you can then access label inside of the &lt;code class=&quot;highlighter-rouge&quot;&gt;c64lib&lt;/code&gt; namespace:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sta MEMORY_CONTROL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but you cannot call &lt;code class=&quot;highlighter-rouge&quot;&gt;getTextOffset&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;configureTextMemory&lt;/code&gt;, because function and macro names are not accessible from outside. User manual of KickAssembler says that this is ‘current state’, so there is a change this will be changed in one of future releases.&lt;/p&gt;

&lt;p&gt;To overcome this limitation, we have to prepend function and macro name with &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; during its declaration which automatically places them in root namespace. In this way we can access it without prepending it with any namespace name, but as it becomes global, it can clash with other names easily. So there are pros and cons.&lt;/p&gt;

&lt;p&gt;What is good, is that we actually have two kind of objects: public (prepended with &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;) and private objects (hidden inside namespace) - we can then define public API of our library and keep the rest as freely modifiable private elements.&lt;/p&gt;

&lt;h2 id=&quot;how-to-use-library-in-another-library&quot;&gt;How to use library (in another library)&lt;/h2&gt;
&lt;p&gt;Assuming you have checked out a library into some common library directory of your choice, using it in your code is relatively simple. Look at my directory structure where I have checked out my libraries:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://maciejmalecki.github.io/blog/cbm/img/travis-ci/library-directory.png&quot; alt=&quot;Content of lib dir&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When using KickAssembler from command line you use &lt;code class=&quot;highlighter-rouge&quot;&gt;-libdir&lt;/code&gt; parameter to specify &lt;code class=&quot;highlighter-rouge&quot;&gt;c64lib&lt;/code&gt; directory location (in my case) and you can write your source code like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;chipset/vic2.asm&quot;
#import &quot;chipset/sprites.asm&quot;
#import &quot;chipset/cia.asm&quot;
#import &quot;common/mem.asm&quot;

*=$0801 &quot;Basic Upstart&quot;
	:BasicUpstart(start)

*=$0810 &quot;Asm Program&quot;
start: {
	jsr initialize
loop:
	inc c64lib.BORDER_COL
	nop
	nop
	nop
	nop
	nop
	nop
	jmp loop
}

initialize: {
	sei
	cli
	rts
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You see: because inside &lt;code class=&quot;highlighter-rouge&quot;&gt;c64lib&lt;/code&gt; dir you have &lt;code class=&quot;highlighter-rouge&quot;&gt;chipset&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;common&lt;/code&gt; checked out, and inside you have &lt;code class=&quot;highlighter-rouge&quot;&gt;vic2.asm&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;sprites.asm&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;cia.asm&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;mem.asm&lt;/code&gt; respectively, all works perfectly (KickAssembler will find these files to include them). All you need to do is to launch it in following way:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -jar KickAss.jar -libdir c:\c\c64lib test.asm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you use IDE such as &lt;a href=&quot;http://www.popelganda.de/relaunch64.html&quot;&gt;Relaunch64&lt;/a&gt;, you must customize Compile &amp;amp; Run Scripts in following way:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://maciejmalecki.github.io/blog/cbm/img/travis-ci/relaunch64.png&quot; alt=&quot;How to customize Relaunch64&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bring-some-automation-with-travis-ci&quot;&gt;Bring some automation with Travis CI&lt;/h2&gt;
&lt;p&gt;Interesting part starts actually here. &lt;a href=&quot;https://travis-ci.org&quot;&gt;TravisCI&lt;/a&gt; is a CI environment that is very well integrated with &lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt;. It is also free for public repositories, so as long as we’re doing Open Source, we don’t have to invest - cool. Once you integrate Travis with your GIT repository, it will start watching for pushes (on any branch, pull request, tag, etc). When new push is detected, it scans your repository for &lt;code class=&quot;highlighter-rouge&quot;&gt;.travis.yml&lt;/code&gt; configuration file and according to what’s inside provides your own temporary little linux machine on which you can actually do anything. Most likely you do a build of your software, you can even launch it and test it if you wish.&lt;/p&gt;

&lt;p&gt;Travis comes with plenty of predefined environments so that you can easily build Java/Maven projects, Ruby, Python, C++ and so on. Surprisingly, there is no environment for KickAssembler available (ha ha ha). Then I actually found, that it is not so easy to provide one, because KickAssembler is a Java application and JVM is available on any Travis environment out of the box! All we need to do is to download KickAssembler at the beginning of our builds and then just use it to build any &lt;code class=&quot;highlighter-rouge&quot;&gt;asm&lt;/code&gt; file you wish.&lt;/p&gt;

&lt;p&gt;I have encapsulated this functionality in separate GIT hub repo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/c64lib/travis-ci&quot;&gt;https://github.com/c64lib/travis-ci&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There is actually some documentation provided how to use (see README). What is important, to use this functionality you must provide &lt;code class=&quot;highlighter-rouge&quot;&gt;.travis.yml&lt;/code&gt; file with similar content:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;asm&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;sudo&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;before_install&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;source &amp;lt;(curl -SLs https://raw.githubusercontent.com/c64lib/travis-ci/master/install.sh)&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cpm common https://github.com/c64lib/common/archive/develop.tar.gz&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cpm chipset https://github.com/c64lib/chipset/archive/develop.tar.gz&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ka -libdir cpm_modules test.asm&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;notifications&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;on_success&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;change&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;on_error&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;change&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First important line is this one:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-SLs&lt;/span&gt; https://raw.githubusercontent.com/c64lib/travis-ci/master/install.sh&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It downloads &lt;code class=&quot;highlighter-rouge&quot;&gt;install.sh&lt;/code&gt; script from repo and sources it (it means it will be immediately executed inside Travis CI environment). What this script does, it download KickAssembler binaries and provides your scripting environment with two further commands: &lt;code class=&quot;highlighter-rouge&quot;&gt;cpm&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ka&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ka&lt;/code&gt; command is just a wrapper for KickAssembler (who wants to type &lt;code class=&quot;highlighter-rouge&quot;&gt;java -jar KickAss.jar&lt;/code&gt; …?) - you now just type &lt;code class=&quot;highlighter-rouge&quot;&gt;ka&lt;/code&gt; and pass all valid KickAssembler parameters to it.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;cpm&lt;/code&gt; command is a very simple tool for managing dependencies. It actually very limited - what it does now, it download specified library from GitHub, unzip it and places in hidden &lt;code class=&quot;highlighter-rouge&quot;&gt;.cpm_modules&lt;/code&gt; directory (JavaScript and NodeJS people already know what is going on;-). Actually it is so limited (I wrote it and tested in 15 minutes), that you must provide it with library name manually, see:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - cpm chipset https://github.com/c64lib/chipset/archive/develop.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(this one downloads content of &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; branch of &lt;code class=&quot;highlighter-rouge&quot;&gt;chipset&lt;/code&gt; library and unzips it under &lt;code class=&quot;highlighter-rouge&quot;&gt;.cpm_modules\chipset&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Because now we are always launching kick assembler in following way:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - ka &lt;span class=&quot;nt&quot;&gt;-libdir&lt;/span&gt; cpm_modules test.asm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;you can reference a library with following import:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;chipset/vic2.asm&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Still, because this facility is very limited, it is useful only for remote builds (CI) on TravisCI. However, I plan to enhance it to be a CLI interface for development environment. But for this you have to wait a while.&lt;/p&gt;

&lt;p&gt;You can refer test library on GitHub:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/c64lib/test&quot;&gt;https://github.com/c64lib/test&lt;/a&gt;&lt;/p&gt;</content><author><name>Maciej Małecki</name></author><summary type="html">It’s a long way I took from early times when I coded something for MOS 65XX family to now, when I actually code for money. What was really a joy or hobby, now becomes a rather routine work guided by corporate processes, software frameworks and project management methodologies. I do not want to complain, I fully understand that productivity is a key and live is hard. When I came back to C64 programming, and that was roughly two years ago (2016) I was just a little bit bored being sick listed because of backbone problems (something very common for programmers of my age). I jumped into very fast, watched bit of excellent 64bites, discovered a wonderful pair of KickAssembler and Relaunch64 and then endless source of information, such as Codebase64 and CovertBitops, to mention just a few. To my great surprise I soon discovered, that something is missing: definitive some processes such as automated builds or CI (continous integration). I’m looking for ready to use, well tested libraries and dependency management system and couldn’t find any. (However, I do not miss any management methodologies…) Just to unlock my brain at this moment, I decided that: I will use GitHub to store and version my code I will use TravisCI to run continous integration of my code I will use excellent features of KickAssembler such as macros, functions and directives and try to write generic, reusable assembly code Challenge accepted. What is a library? Library is just a piece of code that anybody can reuse in other projects just to boost productivity. There are few assumptions that everybody should consider: such code must offer stable API, must be properly versioned (such as I need to use exact version 1.4.0, nothing older but also nothing newer). What does it mean in practice? We need to use any form of source control (GIT and GitHub with its “Releases” feature fits here perfectly). It would be great to have central repository of libraries and dependency management tool just to be able to install or upgrade a library with single CLI command (there are a lot of solutions for other languages such as NPM for JavaScript, PIP for Python, Gems for Ruby, Maven Nexus for Java but sadly nothing for C64 assembly). It would be great that we can integrate assembling and dependency management process into one tool so that we can write “builds” (like with maven, gulp, angular cli, rake). Later I will show, how can we at least partially address these issues for KickAssembler-written libs. What should we put into library? In order to create flexible solution I decided that I will always wrap assembly code in macro while in library. This has two major advantages: Macros can be parametrized, which gives us additional flexibility. We have full freedom where to use macro and thus where in memory will resulting code be located. Let’s assume we have following code in our library: .macro inc16(destination) { inc destination bne !+ inc destination + 1 !: } It increments 16 bit number placed in memory in two memory cells: destination and destination+1 (little endian). Every time it is used it will be exchanged with 3 instructions weighting 8 bytes in total. Of course we can use such “library call” many times, each time we’re adding 8 bytes to total length of our code. There are two more useful types of items we can declare in our library. KickAssembler offers functions, that itself does not evaluate into assembly code but can calculate values that can be later used as immediate value in assembly or in macros. Lets’s consider following function: .function getTextMemory(screenMem, charSet) { .return charSet&amp;lt;&amp;lt;1 | screenMem&amp;lt;&amp;lt;4 } What it does it takes screenMemory slot and charsetSlot and combines it together to get value that can be then stored in $D018 register of VIC-II. This can be used for every 3 text modes of C64. This is how we can use it in code: lda #getTextMemory(1, 4) sta MEMORY_CONTROL Or we can even wrap it into library macro: .macro configureTextMemory(screenMem, charSet) { lda #getTextMemory(screenMem, charSet) sta MEMORY_CONTROL } and then use in code like this: configureTextMemory(1, 4) Last useful item is label. Labels can be used to define constants that can be then reused in different part of library, other libraries or programs. It is definitely easier to read sta MEMORY_CONTROL instead of sta $D017, isn’t it? Here’s example: a beginning of declaration for all VIC-II registers: /* ------------------------------------ * VIC-II registers. * ------------------------------------ */ .label VIC2 = $D000 .label SPRITE_0_X = VIC2 + $00 .label SPRITE_0_Y = VIC2 + $01 .label SPRITE_1_X = VIC2 + $02 .label SPRITE_1_Y = VIC2 + $03 .label SPRITE_2_X = VIC2 + $04 How can we write libraries in assembly? There are three features of KickAssembler that are handy here: The #import directive that includes specified asm file into source code. The namespace feature that allows to isolate objects of library so that they don’t clash with identically named objects of another library. The -libdir parameter that allows to specify additional directory where KickAssembler will look for files to import, so we can keep our libraries checked out in separate folder. Lets look at trivial example: a common library without any additional dependencies: https://github.com/c64lib/common. It consists of several files: .gitignore - these are several build artifacts of KickAssembler that should never be stored in GIT such as *.prg and *.sym files but also a .cbm directory (I will explain that later). .travis.yml - config file for TravisCI - also to be described later. LICENSE, README.md - speak for themselves. common.asm, mem.asm - library files First thing that we see is that it is actually possible to keep several library (asm) files in single ‘library’ module. Splitting code into few smaller files is always good as long as separation is semantically consistent and reasonable. Take a look into common.asm - it is really trivial and short: #importonce .filenamespace c64lib /* * Why Kickassembler does not support bitwise negation on numerical values? * * Params: * value: byte to be negated */ .function neg(value) { .return value ^ $FF } .assert &quot;neg($00) gives $FF&quot;, neg($00), $FF .assert &quot;neg($FF) gives $00&quot;, neg($FF), $00 .assert &quot;neg(%10101010) gives %01010101&quot;, neg(%10101010), %01010101 What is important is header: #importonce says that such file should be imported only once no matter how many times this particular library file is used by all other libraries and files used to assembly our project. Then I declare a namespace: c64lib. I decided to use single namespace for all my libraries because of the namespace problem I have discovered (described in details later). Having separate namespace per library will force me to declare all items ‘public’ which I wanted to avoid. Then we have function documentation (quite important for libraries) - this is logical negation function, by some reason such function is not available in KickAssembler out of the box. Then I wrote several tests in form of KickAssembler asserts: why not to write some unit tests if there is such possibility given by assembler? Small problems Sadly there are few shortcommings of KickAssembler as for now (version 4.x), which make things a little bit more complicated. Firstly, it is not possible to specify more than one diectory with -libdir switch. This is quite easy to workaround - either we need to checkout all libraries into single, common directory, or we can keep it separated and than assemble it into ‘virtual folder’ using symbolic links. Second problem is unfortunately more problematic. The namespace feature is great, as it allows to group labels, macros and functions. But macros and functions are not visible from outside of that particular namespace. So, when you write following code: .namespace c64lib { .label VIC2 = $D000 .label MEMORY_CONTROL = VIC2 + $18 .label TEXT_SCREEN_WIDTH = 40 .function getTextOffset(xPos, yPos) { .return xPos + TEXT_SCREEN_WIDTH * yPos } .macro configureTextMemory(video, charSet) { lda #getTextMemory(video, charSet) sta MEMORY_CONTROL } } you can then access label inside of the c64lib namespace: sta MEMORY_CONTROL but you cannot call getTextOffset or configureTextMemory, because function and macro names are not accessible from outside. User manual of KickAssembler says that this is ‘current state’, so there is a change this will be changed in one of future releases. To overcome this limitation, we have to prepend function and macro name with @ during its declaration which automatically places them in root namespace. In this way we can access it without prepending it with any namespace name, but as it becomes global, it can clash with other names easily. So there are pros and cons. What is good, is that we actually have two kind of objects: public (prepended with @) and private objects (hidden inside namespace) - we can then define public API of our library and keep the rest as freely modifiable private elements. How to use library (in another library) Assuming you have checked out a library into some common library directory of your choice, using it in your code is relatively simple. Look at my directory structure where I have checked out my libraries: When using KickAssembler from command line you use -libdir parameter to specify c64lib directory location (in my case) and you can write your source code like this: #import &quot;chipset/vic2.asm&quot; #import &quot;chipset/sprites.asm&quot; #import &quot;chipset/cia.asm&quot; #import &quot;common/mem.asm&quot; *=$0801 &quot;Basic Upstart&quot; :BasicUpstart(start) *=$0810 &quot;Asm Program&quot; start: { jsr initialize loop: inc c64lib.BORDER_COL nop nop nop nop nop nop jmp loop } initialize: { sei cli rts } You see: because inside c64lib dir you have chipset and common checked out, and inside you have vic2.asm, sprites.asm, cia.asm and mem.asm respectively, all works perfectly (KickAssembler will find these files to include them). All you need to do is to launch it in following way: java -jar KickAss.jar -libdir c:\c\c64lib test.asm If you use IDE such as Relaunch64, you must customize Compile &amp;amp; Run Scripts in following way: Bring some automation with Travis CI Interesting part starts actually here. TravisCI is a CI environment that is very well integrated with GitHub. It is also free for public repositories, so as long as we’re doing Open Source, we don’t have to invest - cool. Once you integrate Travis with your GIT repository, it will start watching for pushes (on any branch, pull request, tag, etc). When new push is detected, it scans your repository for .travis.yml configuration file and according to what’s inside provides your own temporary little linux machine on which you can actually do anything. Most likely you do a build of your software, you can even launch it and test it if you wish. Travis comes with plenty of predefined environments so that you can easily build Java/Maven projects, Ruby, Python, C++ and so on. Surprisingly, there is no environment for KickAssembler available (ha ha ha). Then I actually found, that it is not so easy to provide one, because KickAssembler is a Java application and JVM is available on any Travis environment out of the box! All we need to do is to download KickAssembler at the beginning of our builds and then just use it to build any asm file you wish. I have encapsulated this functionality in separate GIT hub repo: https://github.com/c64lib/travis-ci There is actually some documentation provided how to use (see README). What is important, to use this functionality you must provide .travis.yml file with similar content: language: asm sudo: false before_install: - source &amp;lt;(curl -SLs https://raw.githubusercontent.com/c64lib/travis-ci/master/install.sh) script: - cpm common https://github.com/c64lib/common/archive/develop.tar.gz - cpm chipset https://github.com/c64lib/chipset/archive/develop.tar.gz - ka -libdir cpm_modules test.asm notifications: email: on_success: change on_error: change First important line is this one: source &amp;lt;(curl -SLs https://raw.githubusercontent.com/c64lib/travis-ci/master/install.sh) It downloads install.sh script from repo and sources it (it means it will be immediately executed inside Travis CI environment). What this script does, it download KickAssembler binaries and provides your scripting environment with two further commands: cpm and ka. The ka command is just a wrapper for KickAssembler (who wants to type java -jar KickAss.jar …?) - you now just type ka and pass all valid KickAssembler parameters to it. The cpm command is a very simple tool for managing dependencies. It actually very limited - what it does now, it download specified library from GitHub, unzip it and places in hidden .cpm_modules directory (JavaScript and NodeJS people already know what is going on;-). Actually it is so limited (I wrote it and tested in 15 minutes), that you must provide it with library name manually, see: - cpm chipset https://github.com/c64lib/chipset/archive/develop.tar.gz (this one downloads content of develop branch of chipset library and unzips it under .cpm_modules\chipset). Because now we are always launching kick assembler in following way: - ka -libdir cpm_modules test.asm you can reference a library with following import: #import &quot;chipset/vic2.asm&quot; Still, because this facility is very limited, it is useful only for remote builds (CI) on TravisCI. However, I plan to enhance it to be a CLI interface for development environment. But for this you have to wait a while. You can refer test library on GitHub: https://github.com/c64lib/test</summary></entry><entry><title type="html">Review: New PSU for Commodore 64/128</title><link href="https://maciejmalecki.github.io/blog/new-psu-for-c64" rel="alternate" type="text/html" title="Review&amp;#58; New PSU for Commodore 64/128" /><published>2018-02-04T00:00:00+00:00</published><updated>2018-02-04T00:00:00+00:00</updated><id>https://maciejmalecki.github.io/blog/new-psu-for-c64</id><content type="html" xml:base="https://maciejmalecki.github.io/blog/new-psu-for-c64">&lt;p&gt;Reliability of original C64 CPU has been disputed in community for long time. Commodore had problems with it in the past, plenty of houses were put on fire. Today, over 35 years after first Commodore 64 was produced another issue becomes especially painful: some of bricks decide now to ignore its spec and generate voltage that exceeds its nominal 5VDC thus frying most of precious chips.&lt;/p&gt;

&lt;p&gt;Original PSU is not easy to replace. Commodore decided that C64 must be powered with two types of voltages: 9VAC that is then rectified and regulated by circuit located inside computer and 5VDC that is rectified and regulated by circuit located inside power brick and is used &lt;em&gt;directly&lt;/em&gt; to power most of C64 chips. This second power line is actually critical, because any deviation from pretty narrow voltage range can either cause unstable operation or damage certain chips (or even all of them). Regulation circuit located inside brick proves to do this devastating job very well. For even more exciting details just check &lt;a href=&quot;https://www.c64-wiki.com/wiki/Power_Supply&quot;&gt;this&lt;/a&gt; excellent source.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://maciejmalecki.github.io/blog/cbm/img/psu-rs/psu-comparison.jpg&quot; alt=&quot;Comparison with original units&quot; title=&quot;Comparison with original units&quot; /&gt;
&lt;em&gt;Various units, from left: Ismet supply (“breadbin”), Ismet supply (early C64C), Dee Van unit (C64 short board) and a brand new PSU replacement by &lt;a href=&quot;mailto:raf@c64power.com&quot;&gt;Rafał Szyja&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I wouldn’t exaggerate if I say that using the same PSU for more than 30 years is like playing Russian Roulette. We definitely needs some…&lt;/p&gt;

&lt;h1 id=&quot;alternatives&quot;&gt;…alternatives&lt;/h1&gt;

&lt;p&gt;There are plenty of solutions available, unfortunatelly most of them are DIY, and not everybody have sufficient skills for that. And if have and do something wrong, you may kill a patient. Too bad… Let’s look briefly at options that we have:&lt;/p&gt;

&lt;h2 id=&quot;power-savers&quot;&gt;Power savers&lt;/h2&gt;

&lt;p&gt;Power Saver is an additional overvoltage protection that is plugged between PSU and computer (can be also mounted inside the computer). I think that the idea came originally from &lt;a href=&quot;http://personalpages.tds.net/~rcarlsen/cbm/c64/SAVER/&quot;&gt;Ray Carlsen&lt;/a&gt;. In its simplest form this is electro-mechanical device using relay that turns off 5V DC line when some predefined threshold (i.e. 5.4V) is meet. Ray never claimed that saver is “the final and best solution” - it’s rather workaround of a problem - you can still use your PSU while waiting for new replacement. With saver and original old PSU there is still a risk, that circuit and relay will not react fast enough to save your electronics, if regulator gets badly shorted.&lt;/p&gt;

&lt;p&gt;However, it still makes sense to use saver while using switching PSU replacement:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;After-market power supplies, even switching types, can fail at any time. Switchers are more reliable and much less prone to catastrophic failures but can still cause damage to the computer if they fail. This Saver is designed to protect any computer that uses the standard Commodore “brick” power supply as well as any newer switch-mode PS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;replace-linear-regulator&quot;&gt;Replace linear regulator&lt;/h2&gt;

&lt;p&gt;This is pretty easy DIY fix that someone suggested to me in Facebook discussion: if you’re lucky enough to disassemble your original PSU, you can replace linear regulator with switching regulator such as 5V UBEC, commonly used to power electronics onboard of RC models. Original linear voltage regulator seems to prone to failures which lead to excees voltages, switching regulators should be much more robust.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://maciejmalecki.github.io/blog/cbm/img/psu-rs/ismet-ubec.jpg&quot; alt=&quot;Ismet refurbished with UBEC regulator&quot; title=&quot;Installing UBEC&quot; /&gt;
&lt;em&gt;Old type of Ismet PSU and voltage regulator replacement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This kind of solution may be problematic as not every type of PSU can be easily disassembled. “Brick” units (Dee Van) cannot, because they are filled with epoxy. Old Ismet units can be disassembled however, as they are also partially filled, it may be not easy. New Ismet units (I don’t have any in my collection) are fully repairable.&lt;/p&gt;

&lt;p&gt;There is one little remark from my side: you should check your UBECs carefully before mounting them: they tend to produce slightly different voltages. I also had a bad luck - one of UBECs that I have purchased was internally shorted - it produced exactly the same voltage on output as on input!&lt;/p&gt;

&lt;h2 id=&quot;bundle-two-market-adapters&quot;&gt;Bundle two market adapters&lt;/h2&gt;

&lt;p&gt;Theoretically it is possible to use two separate adapters that are available on market: one for 9VAC line, one for 5VDC line. They can be easily integrated with single DIN plug and once max load parameters are OK, you should be able to turn on your C64 and see a blue screen ;-) This solution is also offered by &lt;a href=&quot;http://personalpages.tds.net/~rcarlsen/custom%20ps.html&quot;&gt;Ray&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Aesthetics of this solution might be questionable but normally you don’t look at your PSU all the time. It can be however difficult to find wall adapters with decent quality - it is both durability (a week ago my 9V adapter for Arduino just blew up after 24hrs of constant working) and quality of current.&lt;/p&gt;

&lt;h2 id=&quot;buy-a-new-one&quot;&gt;Buy a new one&lt;/h2&gt;

&lt;p&gt;Well, we should’ve thought about it earlier, huh? I just got new unit and I’m going to try it out.&lt;/p&gt;

&lt;p&gt;Mainstream producers do not provide replacement units - no surprise here. We must rely on enthusiasts, as usuall. The unit I’m going to describe here has Polish origins. It has been designed and produced by &lt;a href=&quot;mailto:raf@c64power.com&quot;&gt;Rafał Szyja&lt;/a&gt; from &lt;a href=&quot;http://c64power.com&quot;&gt;C64Power.com&lt;/a&gt;. I’ve ordered it and got a package shortly after. Once the box is opened, I found nice looking “brick” in light grey color bundled with white cabling. Unfortunately the DIN plug is black but this is just a minor issue. All my cabling is black anyway…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://maciejmalecki.github.io/blog/cbm/img/psu-rs/psu-overview.jpg&quot; alt=&quot;PSU from Rafał Szyja&quot; title=&quot;Overview of PSU&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The unit is not particularily small. In fact it is bigger than any of original PSUs that are in my possesion (refer the first figure). Rafał decided not to produce dedicated case but to use generic one that is available on the market. Most importantly, we have two power supply units here in fact, bundled in one package. Bigger case also improves cooling (that was actually a weak point of original PSU). Here in fact, I haven’t observed any noticeable heat production, which is very promising.&lt;/p&gt;

&lt;p&gt;I decided to use all my functioning equipment (see pictures) for testing. Because I don’t have appropriate adapter (square power plug), I haven’t tested how PSU cooperates with my flat C128 - for this you have to wait a little bit more. I used this occassion as an excuse to “de-dust” all of my disk drives and use them as parts of testing sets. Because Rafał claims we can draw up to 3A from his supply, I also included my brand new 1541 Ultimate cartridge. For Ultimate II+ do not use auxiliary power supply, so the PSU must provide whole power.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://maciejmalecki.github.io/blog/cbm/img/psu-rs/testing-short-board.jpg&quot; alt=&quot;Testing sets 1&quot; /&gt;
&lt;em&gt;My short-boarded C64C was used both with 1541 Ultimate II+ (I also launched 16MB REU demos) and original 1541II.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;C64C and Ultimate is the combination I use most of the time. I have run this set for more than a month now and noticed no instabilities or other reliability problems. The PSU runs cool and silent. After two hours of operation, temperature of PSU (measured near ventilation holes) have risen from 20°C to 27°C, not even close to capabilities of original unit, that gets really hot after just 30 minutes of operation.&lt;/p&gt;

&lt;p&gt;Next, I have replaced 1541U with real 1541II drive. I deliberately left PSU on the desk, lying nearby floppy drive so see whether it produces any significant interference that may influence the drive. This time I have also no problems - both C64 and 1541II run stable and PSU stayed cool, unlike my original power supply I use for 1541 disk drive (I have also modern replacement for this one, must test it next time - but I don’t even remember who sold me this one).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://maciejmalecki.github.io/blog/cbm/img/psu-rs/testing-long-board.jpg&quot; alt=&quot;Testing sets 2&quot; /&gt;
&lt;em&gt;My older C64C model with long board together plus 1541C and my C64 “breadbin” with 1541 disk drive.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I have also used this PSU with C64 (Assy 250407) and 1541 “toaster”. With this version more chips are using 9VAC line. There was apparently no difference in PSU behavior.&lt;/p&gt;

&lt;p&gt;Last set that I have assembled for this test was C64C with long board connected with 1541 resembling “C” model. I wouldn’t expect any problems here and in fact there none.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Here are some numbers I’ve got from Rafał:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Input: 230V, 50Hz&lt;/li&gt;
  &lt;li&gt;Output: 5V DC 3A, 9V AC 1.1A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sadly, I’m lacking of sufficient electrotechnical skills so I am not able to provide exact measurements of voltage ripple. Once I find someone that can help me with that, I will update this post.&lt;/p&gt;

&lt;p&gt;Power supply is very solid, the cabling is of good quality. I’m not affraid keeping my Commodore on for a long time anymore. &lt;strong&gt;I fully recommend it!&lt;/strong&gt; You can order this unit from &lt;a href=&quot;https://www.facebook.com/rafalszyja?fref=mentions&quot;&gt;Rafał Szyja&lt;/a&gt; (&lt;a href=&quot;https://www.facebook.com/c64power/?fref=mentions&quot;&gt;C64 Power&lt;/a&gt;).&lt;/p&gt;</content><author><name>Maciej Małecki</name></author><summary type="html">Reliability of original C64 CPU has been disputed in community for long time. Commodore had problems with it in the past, plenty of houses were put on fire. Today, over 35 years after first Commodore 64 was produced another issue becomes especially painful: some of bricks decide now to ignore its spec and generate voltage that exceeds its nominal 5VDC thus frying most of precious chips. Original PSU is not easy to replace. Commodore decided that C64 must be powered with two types of voltages: 9VAC that is then rectified and regulated by circuit located inside computer and 5VDC that is rectified and regulated by circuit located inside power brick and is used directly to power most of C64 chips. This second power line is actually critical, because any deviation from pretty narrow voltage range can either cause unstable operation or damage certain chips (or even all of them). Regulation circuit located inside brick proves to do this devastating job very well. For even more exciting details just check this excellent source. Various units, from left: Ismet supply (“breadbin”), Ismet supply (early C64C), Dee Van unit (C64 short board) and a brand new PSU replacement by Rafał Szyja I wouldn’t exaggerate if I say that using the same PSU for more than 30 years is like playing Russian Roulette. We definitely needs some… …alternatives There are plenty of solutions available, unfortunatelly most of them are DIY, and not everybody have sufficient skills for that. And if have and do something wrong, you may kill a patient. Too bad… Let’s look briefly at options that we have: Power savers Power Saver is an additional overvoltage protection that is plugged between PSU and computer (can be also mounted inside the computer). I think that the idea came originally from Ray Carlsen. In its simplest form this is electro-mechanical device using relay that turns off 5V DC line when some predefined threshold (i.e. 5.4V) is meet. Ray never claimed that saver is “the final and best solution” - it’s rather workaround of a problem - you can still use your PSU while waiting for new replacement. With saver and original old PSU there is still a risk, that circuit and relay will not react fast enough to save your electronics, if regulator gets badly shorted. However, it still makes sense to use saver while using switching PSU replacement: After-market power supplies, even switching types, can fail at any time. Switchers are more reliable and much less prone to catastrophic failures but can still cause damage to the computer if they fail. This Saver is designed to protect any computer that uses the standard Commodore “brick” power supply as well as any newer switch-mode PS. Replace linear regulator This is pretty easy DIY fix that someone suggested to me in Facebook discussion: if you’re lucky enough to disassemble your original PSU, you can replace linear regulator with switching regulator such as 5V UBEC, commonly used to power electronics onboard of RC models. Original linear voltage regulator seems to prone to failures which lead to excees voltages, switching regulators should be much more robust. Old type of Ismet PSU and voltage regulator replacement This kind of solution may be problematic as not every type of PSU can be easily disassembled. “Brick” units (Dee Van) cannot, because they are filled with epoxy. Old Ismet units can be disassembled however, as they are also partially filled, it may be not easy. New Ismet units (I don’t have any in my collection) are fully repairable. There is one little remark from my side: you should check your UBECs carefully before mounting them: they tend to produce slightly different voltages. I also had a bad luck - one of UBECs that I have purchased was internally shorted - it produced exactly the same voltage on output as on input! Bundle two market adapters Theoretically it is possible to use two separate adapters that are available on market: one for 9VAC line, one for 5VDC line. They can be easily integrated with single DIN plug and once max load parameters are OK, you should be able to turn on your C64 and see a blue screen ;-) This solution is also offered by Ray. Aesthetics of this solution might be questionable but normally you don’t look at your PSU all the time. It can be however difficult to find wall adapters with decent quality - it is both durability (a week ago my 9V adapter for Arduino just blew up after 24hrs of constant working) and quality of current. Buy a new one Well, we should’ve thought about it earlier, huh? I just got new unit and I’m going to try it out. Mainstream producers do not provide replacement units - no surprise here. We must rely on enthusiasts, as usuall. The unit I’m going to describe here has Polish origins. It has been designed and produced by Rafał Szyja from C64Power.com. I’ve ordered it and got a package shortly after. Once the box is opened, I found nice looking “brick” in light grey color bundled with white cabling. Unfortunately the DIN plug is black but this is just a minor issue. All my cabling is black anyway… The unit is not particularily small. In fact it is bigger than any of original PSUs that are in my possesion (refer the first figure). Rafał decided not to produce dedicated case but to use generic one that is available on the market. Most importantly, we have two power supply units here in fact, bundled in one package. Bigger case also improves cooling (that was actually a weak point of original PSU). Here in fact, I haven’t observed any noticeable heat production, which is very promising. I decided to use all my functioning equipment (see pictures) for testing. Because I don’t have appropriate adapter (square power plug), I haven’t tested how PSU cooperates with my flat C128 - for this you have to wait a little bit more. I used this occassion as an excuse to “de-dust” all of my disk drives and use them as parts of testing sets. Because Rafał claims we can draw up to 3A from his supply, I also included my brand new 1541 Ultimate cartridge. For Ultimate II+ do not use auxiliary power supply, so the PSU must provide whole power. My short-boarded C64C was used both with 1541 Ultimate II+ (I also launched 16MB REU demos) and original 1541II. C64C and Ultimate is the combination I use most of the time. I have run this set for more than a month now and noticed no instabilities or other reliability problems. The PSU runs cool and silent. After two hours of operation, temperature of PSU (measured near ventilation holes) have risen from 20°C to 27°C, not even close to capabilities of original unit, that gets really hot after just 30 minutes of operation. Next, I have replaced 1541U with real 1541II drive. I deliberately left PSU on the desk, lying nearby floppy drive so see whether it produces any significant interference that may influence the drive. This time I have also no problems - both C64 and 1541II run stable and PSU stayed cool, unlike my original power supply I use for 1541 disk drive (I have also modern replacement for this one, must test it next time - but I don’t even remember who sold me this one). My older C64C model with long board together plus 1541C and my C64 “breadbin” with 1541 disk drive. I have also used this PSU with C64 (Assy 250407) and 1541 “toaster”. With this version more chips are using 9VAC line. There was apparently no difference in PSU behavior. Last set that I have assembled for this test was C64C with long board connected with 1541 resembling “C” model. I wouldn’t expect any problems here and in fact there none. Summary Here are some numbers I’ve got from Rafał: Input: 230V, 50Hz Output: 5V DC 3A, 9V AC 1.1A Sadly, I’m lacking of sufficient electrotechnical skills so I am not able to provide exact measurements of voltage ripple. Once I find someone that can help me with that, I will update this post. Power supply is very solid, the cabling is of good quality. I’m not affraid keeping my Commodore on for a long time anymore. I fully recommend it! You can order this unit from Rafał Szyja (C64 Power).</summary></entry></feed>