<!DOCTYPE html>
<html>

<head>
	
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-113535243-4"></script>
	<script>
		var useCookies = (localStorage.getItem('useCookies') === 'true');
		if (useCookies) {
			window.dataLayer = window.dataLayer || [];
			function gtag () {
				dataLayer.push(arguments);
			}
			gtag('js', new Date());
			gtag('config', 'UA-113535243-4', { 'anonymize_ip': true });
		}
	</script>

	

	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Writing and using libraries in KickAssembler</title>
  <meta name="description" content="Here I explain how to write, use and build under travis-ci reusable libraries written in KickAssembler.">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/docu/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.png">

</head>


<body>
	<div id="wrap">

	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/docu/">Home</a>

		<!-- Nav pages -->
		
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	      <a href="/docu/about" title="About">About</a>
	    
	  
	    
	      <a href="/docu/install" title="Installation guide">Install</a>
	    
	  
	    
	      <a href="/docu/news/" title="News">News</a>
	    
	  
	    
	      <a href="/docu/contribute" title="Contribute">Contribute</a>
	    
	  
	    
	      <a href="/docu/privacy" title="Privacy">Privacy</a>
	    
	  

    <!-- Nav links -->
	  <a href="https://github.com/c64lib">Github</a>


	</div>

  <!-- Nav footer -->
	
	  <footer>

</footer>

	

</nav>


    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">
      <a href="/docu/">
          <h1><code>c64lib</code></h1>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	        <a href="/docu/about" title="About">About</a>
	      
	    
	      
	        <a href="/docu/install" title="Installation guide">Install</a>
	      
	    
	      
	        <a href="/docu/news/" title="News">News</a>
	      
	    
	      
	        <a href="/docu/contribute" title="Contribute">Contribute</a>
	      
	    
	      
	        <a href="/docu/privacy" title="Privacy">Privacy</a>
	      
	    

      <!-- Nav links -->
	    <a href="https://github.com/c64lib">Github</a>


    </span>
  </div>
</header>




      

    <!-- Main content -->
	  <div id="container">

		<main>

			<article id="post-page">
	<h2>Writing and using libraries in KickAssembler</h2>		
	<time datetime="2018-04-26T00:00:00+00:00" class="by-line">26 Apr 2018</time>
	<div class="content">

		<p>It’s a long way I took from early times when I coded something for MOS 65XX family to now, when I actually code for money. What was really a joy or hobby, now becomes a rather routine work guided by corporate processes, software frameworks and project management methodologies. I do not want to complain, I fully understand that productivity is a key and live is hard.</p>

<p>When I came back to C64 programming, and that was roughly two years ago (2016) I was just a little bit bored being sick listed because of backbone problems (something very common for programmers of my age). I jumped into very fast, watched bit of excellent <a href="https://64bites.com/">64bites</a>, discovered a wonderful pair of <a href="http://www.theweb.dk/KickAssembler/Main.html">KickAssembler</a> and <a href="http://www.popelganda.de/relaunch64.html">Relaunch64</a> and then endless source of information, such as <a href="http://codebase64.org">Codebase64</a> and <a href="https://cadaver.github.io/" title="Covert Bitops">CovertBitops</a>, to mention just a few.</p>

<p>To my great surprise I soon discovered, that something is missing: definitive some processes such as automated builds or CI (continous integration). I’m looking for ready to use, well tested libraries and dependency management system and couldn’t find any.</p>

<p>(However, I do not miss any management methodologies…)</p>

<p>Just to unlock my brain at this moment, I decided that:</p>
<ul>
  <li>I will use <a href="https://github.com">GitHub</a> to store and version my code</li>
  <li>I will use <a href="https://travis-ci.org">TravisCI</a> to run continous integration of my code</li>
  <li>I will use excellent features of <a href="http://www.theweb.dk/KickAssembler/Main.html">KickAssembler</a> such as macros, functions and directives and try to write generic, reusable assembly code</li>
</ul>

<p>Challenge accepted.</p>

<h2 id="what-is-a-library">What is a library?</h2>
<p>Library is just a piece of code that anybody can reuse in other projects just to boost productivity. There are few assumptions that everybody should consider: such code must offer stable API, must be properly versioned (such as I need to use exact version 1.4.0, nothing older but also nothing newer).</p>

<p>What does it mean in practice?</p>

<ul>
  <li>We need to use any form of source control (GIT and <a href="https://github.com">GitHub</a> with its “Releases” feature fits here perfectly).</li>
  <li>It would be great to have central repository of libraries and dependency management tool just to be able to install or upgrade a library with single CLI command (there are a lot of solutions for other languages such as NPM for JavaScript, PIP for Python, Gems for Ruby, Maven Nexus for Java but sadly nothing for C64 assembly).</li>
  <li>It would be great that we can integrate assembling and dependency management process into one tool so that we can write “builds” (like with maven, gulp, angular cli, rake).</li>
</ul>

<p>Later I will show, how can we at least partially address these issues for KickAssembler-written libs.</p>

<h2 id="what-should-we-put-into-library">What should we put into library?</h2>
<p>In order to create flexible solution I decided that I will always wrap assembly code in macro while in library. This has two major advantages:</p>
<ul>
  <li>Macros can be parametrized, which gives us additional flexibility.</li>
  <li>We have full freedom where to use macro and thus where in memory will resulting code be located.</li>
</ul>

<p>Let’s assume we have following code in our library:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.macro inc16(destination) {
  inc destination
  bne !+
  inc destination + 1
!:
}
</code></pre></div></div>

<p>It increments 16 bit number placed in memory in two memory cells: <code class="highlighter-rouge">destination</code> and <code class="highlighter-rouge">destination+1</code> (little endian). Every time it is used it will be exchanged with 3 instructions weighting 8 bytes in total. Of course we can use such “library call” many times, each time we’re adding 8 bytes to total length of our code.</p>

<p>There are two more useful types of items we can declare in our library.</p>

<p><a href="http://www.theweb.dk/KickAssembler/Main.html">KickAssembler</a> offers functions, that itself does not evaluate into assembly code but can calculate values that can be later used as immediate value in assembly or in macros.</p>

<p>Lets’s consider following function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.function getTextMemory(screenMem, charSet) {
  .return charSet&lt;&lt;1 | screenMem&lt;&lt;4
}
</code></pre></div></div>

<p>What it does it takes screenMemory slot and charsetSlot and combines it together to get value that can be then stored in <code class="highlighter-rouge">$D018</code> register of VIC-II. This can be used for every 3 text modes of C64. This is how we can use it in code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lda #getTextMemory(1, 4)
sta MEMORY_CONTROL
</code></pre></div></div>

<p>Or we can even wrap it into library macro:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.macro configureTextMemory(screenMem, charSet) {
  lda #getTextMemory(screenMem, charSet)
  sta MEMORY_CONTROL
}
</code></pre></div></div>

<p>and then use in code like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>configureTextMemory(1, 4)
</code></pre></div></div>

<p>Last useful item is label. Labels can be used to define constants that can be then reused in different part of library, other libraries or programs. It is definitely easier to read <code class="highlighter-rouge">sta MEMORY_CONTROL</code> instead of <code class="highlighter-rouge">sta $D017</code>, isn’t it?</p>

<p>Here’s example: a beginning of declaration for all VIC-II registers:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* ------------------------------------
 * VIC-II registers.
 * ------------------------------------ */
.label VIC2                 = $D000 
.label SPRITE_0_X           = VIC2 + $00 
.label SPRITE_0_Y           = VIC2 + $01 
.label SPRITE_1_X           = VIC2 + $02 
.label SPRITE_1_Y           = VIC2 + $03 
.label SPRITE_2_X           = VIC2 + $04 
</code></pre></div></div>

<h2 id="how-can-we-write-libraries-in-assembly">How can we write libraries in assembly?</h2>
<p>There are three features of <a href="http://www.theweb.dk/KickAssembler/Main.html">KickAssembler</a> that are handy here:</p>
<ul>
  <li>The <code class="highlighter-rouge">#import</code> directive that includes specified <code class="highlighter-rouge">asm</code> file into source code.</li>
  <li>The namespace feature that allows to isolate objects of library so that they don’t clash with identically named objects of another library.</li>
  <li>The <code class="highlighter-rouge">-libdir</code> parameter that allows to specify additional directory where <a href="http://www.theweb.dk/KickAssembler/Main.html">KickAssembler</a> will look for files to import, so we can keep our libraries checked out in separate folder.</li>
</ul>

<p>Lets look at trivial example: a common library without any additional dependencies: <a href="https://github.com/c64lib/common">https://github.com/c64lib/common</a>. It consists of several files:</p>
<ul>
  <li><code class="highlighter-rouge">.gitignore</code> - these are several build artifacts of KickAssembler that should never be stored in GIT such as <code class="highlighter-rouge">*.prg</code> and <code class="highlighter-rouge">*.sym</code> files but also a <code class="highlighter-rouge">.cbm</code> directory (I will explain that later).</li>
  <li><code class="highlighter-rouge">.travis.yml</code> - config file for <a href="https://travis-ci.org">TravisCI</a> - also to be described later.</li>
  <li><code class="highlighter-rouge">LICENSE</code>, <code class="highlighter-rouge">README.md</code> - speak for themselves.</li>
  <li><code class="highlighter-rouge">common.asm</code>, <code class="highlighter-rouge">mem.asm</code> - library files</li>
</ul>

<p>First thing that we see is that it is actually possible to keep several library (asm) files in single ‘library’ module. Splitting code into few smaller files is always good as long as separation is semantically consistent and reasonable.</p>

<p>Take a look into <code class="highlighter-rouge">common.asm</code> - it is really trivial and short:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#importonce
.filenamespace c64lib

/*
 * Why Kickassembler does not support bitwise negation on numerical values?
 * 
 * Params:
 * value: byte to be negated
 */
.function neg(value) {
	.return value ^ $FF
}
.assert "neg($00) gives $FF", neg($00), $FF
.assert "neg($FF) gives $00", neg($FF), $00
.assert "neg(%10101010) gives %01010101", neg(%10101010), %01010101
</code></pre></div></div>

<p>What is important is header: <code class="highlighter-rouge">#importonce</code> says that such file should be imported only once no matter how many times this particular library file is used by all other libraries and files used to assembly our project.</p>

<p>Then I declare a namespace: <code class="highlighter-rouge">c64lib</code>. I decided to use single namespace for all my libraries because of the namespace problem I have discovered (described in details later). Having separate namespace per library will force me to declare all items ‘public’ which I wanted to avoid.</p>

<p>Then we have function documentation (quite important for libraries) - this is logical negation function, by some reason such function is not available in <a href="http://www.theweb.dk/KickAssembler/Main.html">KickAssembler</a> out of the box.</p>

<p>Then I wrote several tests in form of KickAssembler asserts: why not to write some unit tests if there is such possibility given by assembler?</p>

<h2 id="small-problems">Small problems</h2>
<p>Sadly there are few shortcommings of <a href="http://www.theweb.dk/KickAssembler/Main.html">KickAssembler</a> as for now (version 4.x), which make things a little bit more complicated.</p>

<p>Firstly, it is not possible to specify more than one diectory with <code class="highlighter-rouge">-libdir</code> switch. This is quite easy to workaround - either we need to checkout all libraries into single, common directory, or we can keep it separated and than assemble it into ‘virtual folder’ using symbolic links.</p>

<p>Second problem is unfortunately more problematic. The namespace feature is great, as it allows to group labels, macros and functions. But macros and functions are not visible from outside of that particular namespace. So, when you write following code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.namespace c64lib {
  .label VIC2 = $D000 
  .label MEMORY_CONTROL = VIC2 + $18
  .label TEXT_SCREEN_WIDTH = 40
  
  .function getTextOffset(xPos, yPos) {
    .return xPos + TEXT_SCREEN_WIDTH * yPos
  }

  .macro configureTextMemory(video, charSet) {
    lda #getTextMemory(video, charSet)
    sta MEMORY_CONTROL
  }
}
</code></pre></div></div>

<p>you can then access label inside of the <code class="highlighter-rouge">c64lib</code> namespace:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sta MEMORY_CONTROL
</code></pre></div></div>

<p>but you cannot call <code class="highlighter-rouge">getTextOffset</code> or <code class="highlighter-rouge">configureTextMemory</code>, because function and macro names are not accessible from outside. User manual of KickAssembler says that this is ‘current state’, so there is a change this will be changed in one of future releases.</p>

<p>To overcome this limitation, we have to prepend function and macro name with <code class="highlighter-rouge">@</code> during its declaration which automatically places them in root namespace. In this way we can access it without prepending it with any namespace name, but as it becomes global, it can clash with other names easily. So there are pros and cons.</p>

<p>What is good, is that we actually have two kind of objects: public (prepended with <code class="highlighter-rouge">@</code>) and private objects (hidden inside namespace) - we can then define public API of our library and keep the rest as freely modifiable private elements.</p>

<h2 id="how-to-use-library-in-another-library">How to use library (in another library)</h2>
<p>Assuming you have checked out a library into some common library directory of your choice, using it in your code is relatively simple. Look at my directory structure where I have checked out my libraries:</p>

<p><img src="https://c64lib.github.io/docu/news/img/travis-ci/library-directory.png" alt="Content of lib dir" /></p>

<p>When using KickAssembler from command line you use <code class="highlighter-rouge">-libdir</code> parameter to specify <code class="highlighter-rouge">c64lib</code> directory location (in my case) and you can write your source code like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "chipset/vic2.asm"
#import "chipset/sprites.asm"
#import "chipset/cia.asm"
#import "common/mem.asm"

*=$0801 "Basic Upstart"
	:BasicUpstart(start)

*=$0810 "Asm Program"
start: {
	jsr initialize
loop:
	inc c64lib.BORDER_COL
	nop
	nop
	nop
	nop
	nop
	nop
	jmp loop
}

initialize: {
	sei
	cli
	rts
}
</code></pre></div></div>

<p>You see: because inside <code class="highlighter-rouge">c64lib</code> dir you have <code class="highlighter-rouge">chipset</code> and <code class="highlighter-rouge">common</code> checked out, and inside you have <code class="highlighter-rouge">vic2.asm</code>, <code class="highlighter-rouge">sprites.asm</code>, <code class="highlighter-rouge">cia.asm</code> and <code class="highlighter-rouge">mem.asm</code> respectively, all works perfectly (KickAssembler will find these files to include them). All you need to do is to launch it in following way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java -jar KickAss.jar -libdir c:\c\c64lib test.asm
</code></pre></div></div>

<p>If you use IDE such as <a href="http://www.popelganda.de/relaunch64.html">Relaunch64</a>, you must customize Compile &amp; Run Scripts in following way:</p>

<p><img src="https://c64lib.github.io/docu/cbm/img/travis-ci/relaunch64.png" alt="How to customize Relaunch64" /></p>

<h2 id="bring-some-automation-with-travis-ci">Bring some automation with Travis CI</h2>
<p>Interesting part starts actually here. <a href="https://travis-ci.org">TravisCI</a> is a CI environment that is very well integrated with <a href="https://github.com">GitHub</a>. It is also free for public repositories, so as long as we’re doing Open Source, we don’t have to invest - cool. Once you integrate Travis with your GIT repository, it will start watching for pushes (on any branch, pull request, tag, etc). When new push is detected, it scans your repository for <code class="highlighter-rouge">.travis.yml</code> configuration file and according to what’s inside provides your own temporary little linux machine on which you can actually do anything. Most likely you do a build of your software, you can even launch it and test it if you wish.</p>

<p>Travis comes with plenty of predefined environments so that you can easily build Java/Maven projects, Ruby, Python, C++ and so on. Surprisingly, there is no environment for KickAssembler available (ha ha ha). Then I actually found, that it is not so easy to provide one, because KickAssembler is a Java application and JVM is available on any Travis environment out of the box! All we need to do is to download KickAssembler at the beginning of our builds and then just use it to build any <code class="highlighter-rouge">asm</code> file you wish.</p>

<p>I have encapsulated this functionality in separate GIT hub repo:</p>

<p><a href="https://github.com/c64lib/travis-ci">https://github.com/c64lib/travis-ci</a></p>

<p>There is actually some documentation provided how to use (see README). What is important, to use this functionality you must provide <code class="highlighter-rouge">.travis.yml</code> file with similar content:</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">language</span><span class="pi">:</span> <span class="s">asm</span>
<span class="na">sudo</span><span class="pi">:</span> <span class="no">false</span>
<span class="na">before_install</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">source &lt;(curl -SLs https://raw.githubusercontent.com/c64lib/travis-ci/master/install.sh)</span>
<span class="na">script</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">cpm common https://github.com/c64lib/common/archive/develop.tar.gz</span>
  <span class="pi">-</span> <span class="s">cpm chipset https://github.com/c64lib/chipset/archive/develop.tar.gz</span>
  <span class="pi">-</span> <span class="s">ka -libdir cpm_modules test.asm</span>
<span class="na">notifications</span><span class="pi">:</span>
  <span class="na">email</span><span class="pi">:</span>
     <span class="na">on_success</span><span class="pi">:</span> <span class="s">change</span>
     <span class="na">on_error</span><span class="pi">:</span> <span class="s">change</span>
</code></pre></div></div>

<p>First important line is this one:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> &lt;<span class="o">(</span>curl <span class="nt">-SLs</span> https://raw.githubusercontent.com/c64lib/travis-ci/master/install.sh<span class="o">)</span>
</code></pre></div></div>
<p>It downloads <code class="highlighter-rouge">install.sh</code> script from repo and sources it (it means it will be immediately executed inside Travis CI environment). What this script does, it download KickAssembler binaries and provides your scripting environment with two further commands: <code class="highlighter-rouge">cpm</code> and <code class="highlighter-rouge">ka</code>.</p>

<p>The <code class="highlighter-rouge">ka</code> command is just a wrapper for KickAssembler (who wants to type <code class="highlighter-rouge">java -jar KickAss.jar</code> …?) - you now just type <code class="highlighter-rouge">ka</code> and pass all valid KickAssembler parameters to it.</p>

<p>The <code class="highlighter-rouge">cpm</code> command is a very simple tool for managing dependencies. It actually very limited - what it does now, it download specified library from GitHub, unzip it and places in hidden <code class="highlighter-rouge">.cpm_modules</code> directory (JavaScript and NodeJS people already know what is going on;-). Actually it is so limited (I wrote it and tested in 15 minutes), that you must provide it with library name manually, see:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - cpm chipset https://github.com/c64lib/chipset/archive/develop.tar.gz
</code></pre></div></div>
<p>(this one downloads content of <code class="highlighter-rouge">develop</code> branch of <code class="highlighter-rouge">chipset</code> library and unzips it under <code class="highlighter-rouge">.cpm_modules\chipset</code>).</p>

<p>Because now we are always launching kick assembler in following way:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - ka <span class="nt">-libdir</span> cpm_modules test.asm
</code></pre></div></div>
<p>you can reference a library with following import:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "chipset/vic2.asm"
</code></pre></div></div>

<p>Still, because this facility is very limited, it is useful only for remote builds (CI) on TravisCI. However, I plan to enhance it to be a CLI interface for development environment. But for this you have to wait a while.</p>

<p>You can refer test library on GitHub:</p>

<p><a href="https://github.com/c64lib/test">https://github.com/c64lib/test</a></p>


		
	</div>
</article>



	  </main>

		  <!-- Pagination links -->
      

	  </div>

	    <!-- Footer -->
	    <footer><span>&#169; 2018-2019 <code>c64lib</code> &#10540; last update: 2019-12-06 23:16</span></footer>


      <div id="gdpr" style="display: none;">
        <p>
          This web page uses cookies to track anonymous user activities. By continuing using this site
          or by closing this banner you indicate your consent to use these cookies.
          You can change settings, i.e. disable user tracking on <a href="privacy.html">privacy</a> page.
        </p>
        <button id="gdprClose">Close</button>
      </div>

	    <!-- Script -->
      <script src="/docu/js/main.js"></script>	


	</div>

</body>
</html>
